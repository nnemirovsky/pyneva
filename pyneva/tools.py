import re
from re import Match
from typing import Literal

from .types import IdentificationMsg, DataMsg, ErrorMessageReceived, WrongBCC, ResponseError


def make_cmd_msg(obis: str = "", mode: Literal["P", "W", "R"] = "R", data: bytes = b"") -> bytes:
    """
    Returns generated byte command message from OBIS code or password comparison message.
    If data has been specified mode should be "W" or "P".
    """
    if type(obis) != str:
        raise TypeError(f"OBIS must be str, not {type(obis).__name__}")

    if type(data) != bytes:
        raise TypeError(f"data must be bytes, not {type(data).__name__}")

    if mode not in ("P", "W", "R"):
        raise ValueError(f"mode must be in ('P', 'W', 'R'), not {mode!r}")

    if mode in ("P", "W") and not data:
        raise ValueError("data cannot be empty if mode in ('P', 'W')")

    if not obis and mode in ("R", "W"):
        raise ValueError("if mode == 'W' OBIS code must be specified")

    if obis and mode == "P":
        raise ValueError("mode cannot be 'P' if OBIS code was specified")

    if obis:
        pattern = r"({a})\.({a})\.({a})\*({a})".format(a="[A-F0-9]{2}")
        pattern = re.compile(pattern)
        obis = pattern.fullmatch(obis)
        if not obis:
            raise ValueError("OBIS code format is wrong")
        obis = obis[1] + obis[2] + obis[3] + obis[4]

    msg = b"\x01%s1\x02%s(%s)\x03" % (mode.encode(), obis.encode(), data)
    msg += calculate_bcc(msg[1:])
    return msg


def parse_id_msg(response: bytes) -> IdentificationMsg:
    if not isinstance(response, bytes):
        raise TypeError(f"response must be bytes, not {type(response).__name__}")
    pattern = b"^\\/(?P<vendor>[A-Z]{2}([A-Z]|[a-z]))(?P<baudrate>[0-5])(?P<ident>" \
              b"[\x22-\x2E\x30-\x7E]{1,16})\r\n$"
    pattern = re.compile(pattern)
    id_msg = pattern.fullmatch(response)
    if not id_msg:
        raise ResponseError(f"invalid identification message format, msg: {response}")
    identity = id_msg.group("ident").decode("ascii")
    vendor = id_msg.group("vendor").decode("ascii")
    baudrate_num = int(id_msg.group("baudrate"))
    return IdentificationMsg(ident=identity, vendor=vendor, baudrate_num=baudrate_num)


def parse_password_msg(response: bytes) -> bytes:
    if not isinstance(response, bytes):
        raise TypeError(f"response must be bytes, not {type(response).__name__}")
    pattern = b"^\x01P0\x02\\((?P<data>.*)\\)\x03(?P<bcc>[\x00-\xff])$"
    pattern = re.compile(pattern)
    pass_msg = pattern.fullmatch(response)
    if not pass_msg:
        raise ResponseError(f"invalid password message format, msg: {response}")
    check_bcc(pass_msg)
    return pass_msg.group("data")


def check_err(response: bytes):
    pattern = b"^\x02\\((?P<err>[0-9]+)\\)\x03[\x00-\xff]$"
    pattern = re.compile(pattern)
    response = pattern.fullmatch(response)
    if response:
        raise ErrorMessageReceived(f"error code: {response['err'].decode('ascii')}")


def parse_data_msg(response: bytes) -> DataMsg:
    if not isinstance(response, bytes):
        raise TypeError(f"response must be bytes, not {type(response).__name__}")
    pattern = b"^\x02(?P<addr>[0-9A-F]{8})\\((?P<data>.*)\\)\x03(?P<bcc>[\x00-\xff])$"
    pattern = re.compile(pattern)
    data_msg = pattern.fullmatch(response)
    if not data_msg:
        check_err(response)
        raise ResponseError(f"invalid data message format, msg: {response}")
    check_bcc(data_msg)
    data = data_msg["data"].split(b",")
    if b"." in data[0]:
        if len(data) != 1:
            data = tuple(map(float, data))
        else:
            data = float(data[0])
    elif len(data) != 1:
        data = tuple(map(lambda x: x.decode("ascii"), data))
    else:
        data = data[0].decode("ascii")
    address = data_msg["addr"].decode("ascii")
    address = f"{address[:2]}.{address[2:4]}.{address[4:6]}*{address[6:]}"
    return DataMsg(data=data, address=address)


def parse_schedules(schedules: tuple[str, ...]) -> tuple[tuple[int, ...], ...]:
    schedules_parsed = []
    for skd in schedules:
        if int(skd):
            schedules_parsed.append(tuple(int(skd[i:i + 2]) for i in range(0, len(skd), 2)))
    return tuple(schedules_parsed)


def check_bcc(msg: Match[bytes]):
    """Check that BCC from the response message is correct."""
    calc_bcc = calculate_bcc(msg[0][1:-1])
    if calc_bcc != msg["bcc"]:
        raise WrongBCC(f"BCC must be {calc_bcc}, but received {msg['bcc']}")


def calculate_bcc(data: bytes) -> bytes:
    """Returns calculated BCC (block check character)."""
    if type(data) != bytes:
        raise TypeError(f"data must be bytes, not {type(data).__name__}")
    bcc = 0
    for byte in data:
        bcc ^= byte
    return bcc.to_bytes(1, "little")
